#!/usr/bin/env python3
import sys
import os
from datetime import datetime
from collections import defaultdict

def parse_error(message, line_number, line_content):
    raise SyntaxError("Parse Error: {},\n\t line {}: \"{}\"".format(message,line_number,line_content.strip()))

def parse(lines):
    signals = []
    stages = []
    patterns = defaultdict(str)
    current_stage = None
    for i, line_orig in enumerate(lines):
        line = line_orig.split("#")[0].strip()
        if len(line) == 0:
            continue
        if line.startswith("sig"):
            toks = line.split()
            if len(toks) != 2:
                parse_error("Signal definition",i,line_orig)
            signals.append(toks[1])
            continue
        if line.startswith('stage'):
            toks = line.split()
            if len(toks) != 3:
                parse_error("Stage definition",i,line_orig)
            stages.append( (toks[1],int(toks[2])) )
            current_stage = toks[1]
            continue
        toks = [t.strip() for t in line.split(':')]
        if len(toks) != 2:
            parse_error("Pattern definition",i,line_orig)
        sig = toks[0]
        if sig not in signals:
            parse_error("Undefined signal: {}".format(sig),i,line_orig)
        pat = toks[1].replace(" ","").replace("-","1").replace("_","0")
        if not set(pat).issubset(set(['0','1'])):
            parse_error("Bad character",i,line_orig)
        patterns[(sig,current_stage)] += pat

    for stage,_ in stages:
        n = len(patterns[(signals[0],stage)])
        for signal in signals:
            if len(patterns[(signal,stage)]) != n:
                raise SyntaxError("Uneven pattern length for signal:{}, stage:{}".format(signal,stage))

    return signals, stages, patterns

def make_vhdl_inner(signals, stages, patterns):
    vhdl = []
    for stage_num, (stage, iters) in enumerate(stages):
        stage_vhdl = []
        n = len(patterns[(signals[0],stage)])
        for i in range(n):
            step_vhdl = []
            for signal in signals:
                pattern = patterns[(signal,stage)]
                if i < 1 or pattern[i-1] != pattern[i]:
                    step_vhdl.append("\t\t{} <= '{}';".format(signal,pattern[i]))
            if len(step_vhdl) > 0:
                stage_vhdl.append("\tIF(counter = {}) THEN".format(i))
                stage_vhdl.extend(step_vhdl)
                stage_vhdl.append("\tEND IF;")
        if len(stage_vhdl) > 0:
            vhdl.append("IF(stage = {}) THEN".format(stage_num))
            vhdl.extend(stage_vhdl)
            vhdl.extend([
                "\tIF(counter = {}) THEN".format(n-1),
                "\t\tIF(stage_iter = {}) THEN".format(iters-1),
                "\t\t\tstage <= (stage + 1) MOD {};".format(len(stages)),
                "\t\t\tstage_iter <= 0;",
                "\t\tELSE",
                "\t\t\tstage_iter <= stage_iter + 1;",
                "\t\tEND IF;",
                "\t\tcounter <= 0;",
                "\tELSE",
                "\t\tcounter <= counter + 1;",
                "\tEND IF;",
                "END IF;"])
    return vhdl

def make_vhdl_full(signals, vhdl_inner):
    vhdl_inner = ["\t\t\t"+x for x in vhdl_inner]
    vhdl = []
    vhdl.extend([
        "library ieee;",
        "use ieee.std_logic_1164.all;",
        "use ieee.numeric_std.all;",
        "",
        "ENTITY step_curve IS",
        "\tPORT(",
        "\t\tclk: IN std_logic;"
    ])
    for sig_name in signals:
        vhdl.append("\t\t{} : OUT std_logic;".format(sig_name))
    vhdl[-1] = vhdl[-1][:-1] #remove ';' from last item
    vhdl.extend([
        "\t);",
        "END step_curve;",
        "",
        "ARCHITECTURE step_curve_arch OF step_curve IS",
        "SIGNAL counter:      integer := 0;",
        "SIGNAL stage:        integer := 0;",
        "SIGNAL stage_iter:   integer := 0;",
        "BEGIN",
        "\tPROCESS (clk)",
        "\tBEGIN",
        "\t\tIF(rising_edge(clk)) THEN"
    ])
    vhdl.extend(vhdl_inner)
    vhdl.extend([
        "\t\tEND IF;",
        "\tEND PROCESS;",
        "END step_curve_arch;"
    ])
    return '\n'.join(vhdl)


def main(infile_name, outfile_name):
    with open(infile_name) as infile:
        lines = infile.readlines()
    signals, stages, patterns = parse(lines)
    vhdl_inner = make_vhdl_inner(signals, stages, patterns)
    vhdl_full = make_vhdl_full(signals,vhdl_inner)
    with open(outfile_name,'w') as outfile:
        outfile.write("--Autogenerated VHDL on {}\n\n".format(datetime.now()))
        outfile.write(vhdl_full)
    print(vhdl_full)

if __name__ == "__main__":
    args = sys.argv
    if(len(args) != 2):
        print("USAGE: ./pattern_gen.py inFile")
        sys.exit(1)
    infile_name = args[1]
    outfile_name = '.'.join(infile_name.split('.')[:-1]) + '.vhdl'
    if(not os.path.exists(args[1])):
        print("ERROR: Input file {} not found".format(args[1]))
        sys.exit(1)
    if(os.path.exists(outfile_name)):
        os.remove(outfile_name)
    main(infile_name, outfile_name)
