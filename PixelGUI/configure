#!/bin/bash
 #  configure
 # 		Author: Caleb Fangmeier
 # 		contact: cfangmeier74@gmail.com
 # 		date: May 18, 2011
 # 		
 # 	Creates the pixelGUI_Linkdef.h file and makefile for PixelGUI by examining
 # 	the list of classes in classes.txt. It can also customize the GUI for any
 # 	pixelTree(I think...) by allowing the user to pass a sample ROOT file as an
 # 	optional argument. The script will then call root to make a temporary 
 # 	class. The script will then get the branches from the temporary class
 # 	and put them into anaPixelTree. To use this script the user must have 
 # 	awk and root installed on their system.

if [[ $# == 1 && $1 == "--help" ]] 
	then
	clear
	echo "
		configure for PixelGUI v1.0
	Author: Caleb Fangmeier
	contact: cfangmeier74@gmail.com
	date: May 18, 2011

Will autocreate pixelGUI_Linkdef.h, and Makefile from the list
of classes stored in classes.txt. Also an optional parameter of
a .root file containing a pixelTree can be used to autocreate
anaPixelTree bases on its contents.

eg:
$./configure /home/user/storage/pixeltree-XXXX.root

Zero arguments will do everything but the anaPixelTree creation.
"
	exit 0
fi


#FIRST PARSE THE CLASS NAMES FROM classes.txt  AND STORE THEM IN AN ARRAY
index="1"
declare -a classes
Date=$(date)

while read class
	do
	start=${class:0:1}
	if [ "#" == $start ]
		then
			echo -n ""
		else
			classes[$index]=$class
			#echo ${classes[$index]}
			let index+=1	
	fi
done < <(cat  classes.txt)


#REMOVE AND RECREATE FILES
rm -f PixelGUI_Linkdef.h Makefile
touch PixelGUI_Linkdef.h Makefile


#CREATE THE LINKDEF FILE
echo "/*  PixelGUI_Linkdef.h
 *  	Author: Caleb Fangmeier
 * 		contact: cfangmeier@hotmail.com
 * 		date: $Date
 * 	
 * 		This class is required by rootcint to create all of the necessary
 * 		libraries that g++ will require to compile the gui. List all classes
 * 		here that are being used by PixelGUI.
 *  	AUTOGENERATED BY: $0
 */
" >> PixelGUI_Linkdef.h



for element in $(seq 1 $((${#classes[@]})))
  do                
  echo -n "	#pragma link C++ class "  >> PixelGUI_Linkdef.h
  echo "${classes[$element]};" >> PixelGUI_Linkdef.h
done

echo "PixelGUI_Linkdef.h Created!"


#CREATE THE MAKEFILE
echo "  #
 #  Makefile
 #  
 #
 #  Created by Tony Kelly II on 5/28/10.
 #  Modified by Caleb Fangmeier on 7/09/10 to build PixelGUI
 #                                 5/10/11 for improved speed
 #  This is the makefile which is used to compile all the
 #		necessary implimentation files and build all the
 #		libraries that the GUI needs.
 #
 #
#
#  Defining some variables to make changing the compiling
#	options later an easier task.  This is just in case
#	the GUI grows to unforseen proportions.
#
CC=g++
CFLAGS=\`root-config --cflags --glibs\`
LDFLAGS=\`root-config --cflags\`
" >> Makefile

echo "#List here an object file for each class that needs to be compiled" >> Makefile
echo -n "objects = " >> Makefile
for element in $(seq 2 $((${#classes[@]})))
  do                
  echo -n "${classes[$element]}.o " >> Makefile
  
done
echo " " >> Makefile
echo "#List here header files needed by rootcint" >> Makefile

echo -n "headers = " >> Makefile
for element in $(seq 1 $((${#classes[@]})))
  do                
  echo -n "${classes[$element]}.h " >> Makefile
  
done

echo "
PixelGUI: PixelGUI_Dict.cc \$(objects) PixelGUI.cc PixelGUI.h
	\$(CC) \$(CFLAGS) -o PixelGUI PixelGUI.cc \$(objects) PixelGUI_Dict.cc
	@clear
	@echo Done Compiling all Routines" >> Makefile

for element in $(seq 2 $((${#classes[@]})))
  do                
  echo "${classes[$element]}.o: ${classes[$element]}.h ${classes[$element]}.cc " >> Makefile
  echo "	\$(CC) \$(LDFLAGS) -c -o ${classes[$element]}.o ${classes[$element]}.cc " >> Makefile
  #echo ""
done

echo "PixelGUI_Dict.cc: \$(headers) PixelGUI_Linkdef.h
	rootcint -f PixelGUI_Dict.cc -c \$(headers) PixelGUI_Linkdef.h

clean:
	@rm -rf *.o PixelGUI PixelGUI_Dict.*" >> Makefile
echo "Makefile Created!"


#Configure anaPixelTree.h and anaPixelTree.cc

if [ $# == 1 ]
	then
	echo "argument specified, will attempt to configure anaPixelTree"
	echo $1
	suffix=${1:(-5)}
	if [[ "$suffix" == ".root" && -f $1 ]]
		then
		echo "is root file"
		FILENAME=$1
		FILENAME=${FILENAME%.*}
		FILENAME=${FILENAME##*/}
		echo $FILENAME
		ROOTScript="$FILENAME.C"
		rm -f $ROOTScript temp001.txt temp002.txt temp003.txt pixeltreeclass001.h pixeltreeclass001.C
		touch $ROOTScript temp001.txt temp002.txt temp003.txt
		echo "{
		TFile *_file0 = TFile::Open(\"$1\");
		pixelTree->MakeClass(\"pixeltreeclass001\");
		}" >> $ROOTScript
		root -q -l $ROOTScript
		
		linestart=$(awk "/Declaration/ { print(NR) }" pixeltreeclass001.h)
		lineend=$(awk "/List of branches/ { print(NR) }" pixeltreeclass001.h)
		
		linestart=`expr $linestart + 1`
		lineend=`expr $lineend - 2`
		
		#~ awk "{ if ( NR >= $linestart && NR <= $lineend){print;}}" pixeltreeclass001.h >> temp001.txt
		
		PVMAX=[100]
		MUMAX=[100]
		TRACKMAX=[10000]
		CLPERTRACKMAX=[20]
		CLUSTERMAX=[100000]
		DGPERCLMAX=[100]
		TKPERCLMAX=[100]
		SIMHITPERCLMAX=[10]
		SIMTRKPERCLMAX=[10]
		DIGIMAX=[1000000]
		
		
		while read line
			do
			suffix=$(echo $line | awk 'BEGIN{FS="//"} {print $2}')
			prefix=$(echo $line | awk 'BEGIN{FS="["} {print $1}')
			fields=$(echo $line | awk 'BEGIN{FS="["} {print NF}')
			
			case $suffix in
				"[PvN]" )
					echo $prefix$PVMAX";  // [PvN]" >> temp001.txt;;
				"[MuN]" )
					echo $prefix$MUMAX";  // [MuN]" >> temp001.txt;;
				"[TkN]" )
					if [ $fields == 4 ] 
						then
						
						echo "$prefix$TRACKMAX$CLPERTRACKMAX;  // [TkN]" >> temp001.txt
						else
						echo $prefix$TRACKMAX";  // [TkN]" >> temp001.txt
						
					fi ;;
					
				"[ClN]" )
					if [ $fields == 4 ] 
						then
						
						echo $prefix$CLUSTERMAX$TKPERCLMAX";  // [ClN]" >> temp001.txt
						else
						echo $prefix$TRACKMAX";  // [ClN]" >> temp001.txt
						
					fi;;
				"[DgN]" )
					echo $prefix$DIGIMAX";  // [DgN]" >> temp001.txt;;
				*       )
					echo  $line  >> temp001.txt ;;
			esac
			
		done < <(awk "{ if ( NR >= $linestart && NR <= $lineend){print;}}" pixeltreeclass001.h)
		
		
		linestart=`expr $lineend + 2`
		lineend=$(awk "/pixeltreeclass001\(TTree \*tree=0\)/ { print(NR); }" pixeltreeclass001.h)
		lineend=`expr $lineend - 2`
		awk "{ if ( NR >= $linestart && NR <= $lineend){print;}}" pixeltreeclass001.h >> temp002.txt
		
		
		linestart=$(awk "/fChain->SetMakeClass\(1\)/ { print(NR); }" pixeltreeclass001.h)
		lineend=$(awk "/Bool_t pixeltreeclass001/ { print(NR); }" pixeltreeclass001.h)
		linestart=`expr $linestart + 2`
		lineend=`expr $lineend - 4`
		awk "{ if ( NR >= $linestart && NR <= $lineend){print;}}" pixeltreeclass001.h >> temp003.txt
		
		rm -f anaPixelTree.h anaPixelTree.cc
		touch anaPixelTree.h anaPixelTree.cc
		
		echo "/*  anaPixelTree.h
 *  	Author: Caleb Fangmeier
 * 		contact: cfangmeier@hotmail.com
 * 		date: $Date
 * 
 * 		anaPixelTree was originally created by from a pixelTree n-tuple
 * 		via TTree::MakeClass(). It was later modifed to integrate its
 * 		functionality into PixelGUI.
 *		AUTOGENERATED BY: $0
 */

#ifndef anaPixelTree_h
#define anaPixelTree_h

#include <iostream>
#include <fstream>
#include <sstream>
#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>
#include <TH1.h>
#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>

using namespace std;

class anaPixelTree {
	public :
	TTree          *fChain;   //!pointer to the analyzed TTree or TChain
	Int_t           fCurrent; //!current Tree number in a TChain
	" >> anaPixelTree.h
		cat temp001.txt >> anaPixelTree.h
		echo >> anaPixelTree.h
		cat temp002.txt >> anaPixelTree.h
		
		echo "
	anaPixelTree();
	anaPixelTree(TChain *pixelTree);
	virtual ~anaPixelTree();
	virtual Int_t    Cut(Long64_t entry);
	virtual Int_t    GetEntry(Long64_t entry);
	virtual Long64_t LoadTree(Long64_t entry);
	virtual void     Init(TTree *tree);
	virtual void     Loop(int nevt = -1)     = 0; //implemented by child class
	virtual Bool_t   Notify();
	virtual void     Show(Long64_t entry = -1);
};

#endif


" >> anaPixelTree.h
		
		
		echo -n "/*  anaPixelTree.cc
 *  	Author: Caleb Fangmeier
 * 		contact: cfangmeier@hotmail.com
 * 		date: $Date
 * 
 * 		anaPixelTree was originally created by from a pixelTree n-tuple
 * 		via TTree::MakeClass(). It was later modifed to integrate its
 * 		functionality into PixelGUI.
		AUTOGENERATED BY: $0
 */

#ifndef anaPixelTree_cxx
#define anaPixelTree_cxx
#include \"anaPixelTree.h\"




anaPixelTree::anaPixelTree(){}

anaPixelTree::anaPixelTree(TChain *pixelTree) {
	TChain *chain = new TChain(\"pixelTree\",\"\");
	chain->Add(pixelTree);

	Init(chain);
}

anaPixelTree::~anaPixelTree()
{
	if (!fChain) return;
	delete fChain->GetCurrentFile();
}

Int_t anaPixelTree::GetEntry(Long64_t entry)
{
	// Read contents of entry.
	if (!fChain) return 0;
	return fChain->GetEntry(entry);
}

Long64_t anaPixelTree::LoadTree(Long64_t entry)
{
	// Set the environment to read one entry
	if (!fChain) return -5;
	Long64_t centry = fChain->LoadTree(entry);
	if (centry < 0) return centry;
	if (!fChain->InheritsFrom(TChain::Class()))  return centry;
	TChain *chain = (TChain*)fChain;
	if (chain->GetTreeNumber() != fCurrent) {
		fCurrent = chain->GetTreeNumber();
		Notify();
	}
	return centry;
}

void anaPixelTree::Init(TTree *tree)
{
	// The Init() function is called when the selector needs to initialize
	// a new tree or chain. Typically here the branch addresses and branch
	// pointers of the tree will be set.
	// It is normally not necessary to make changes to the generated
	// code, but the routine can be extended by the user if needed.
	// Init() will be called many times when running on PROOF
	// (once per file to be processed).
	
	// Set branch addresses and branch pointers
	if (!tree) return;
	fChain = tree;
	fCurrent = -1;
	fChain->SetMakeClass(1);
	" >> anaPixelTree.cc
		cat temp003.txt >> anaPixelTree.cc
		
		echo -n "	Notify();
}

Bool_t anaPixelTree::Notify()
{
	// The Notify() function is called when a new file is opened. This
	// can be either for a new TTree in a TChain or when when a new TTree
	// is started when using PROOF. It is normally not necessary to make changes
	// to the generated code, but the routine can be extended by the
	// user if needed. The return value is currently not used.
	
	return kTRUE;
}

void anaPixelTree::Show(Long64_t entry)
{
	// Print contents of entry.
	// If entry is not specified, print current entry
	if (!fChain) return;
	fChain->Show(entry);
}

Int_t anaPixelTree::Cut(Long64_t entry)
{
	// This function may be called from Loop.
	// returns  1 if entry is accepted.
	// returns -1 otherwise.
	return 1;
}
#endif
" >> anaPixelTree.cc
		
		rm -f $ROOTScript temp001.txt temp002.txt temp003.txt pixeltreeclass001.h pixeltreeclass001.C
		echo "anaPixelTree Created!"
	fi
	
fi


